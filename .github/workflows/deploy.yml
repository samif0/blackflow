name: CI/CD Deployment Pipeline

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci 
      
      - name: Run tests
        run: npm test || echo "No tests available yet"
      
      - name: Install dos2unix
        run: sudo apt-get update && sudo apt-get install -y dos2unix
  
  deploy-consolidated:
    name: Deploy to Consolidated Environment
    needs: test
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install dos2unix
      run: sudo apt-get update && sudo apt-get install -y dos2unix
    
    - name: Fix line endings in scripts
      run: |
        find scripts -name "*.sh" -type f -exec dos2unix {} \;
        echo "Converted all shell scripts to Unix line endings"
    
    - name: Install SSH Key
      uses: shimataro/ssh-key-action@v2
      with:
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        name: id_ed25519
        known_hosts: ${{ secrets.SSH_KNOWN_HOSTS }}
        if_key_exists: replace
    
    - name: Create environment files
      run: |
        # Create staging environment file
        echo "version: '3'" > docker-compose.staging.yml
        echo "services:" >> docker-compose.staging.yml
        echo "  blackflow-staging:" >> docker-compose.staging.yml
        echo "    environment:" >> docker-compose.staging.yml
        echo "      - NODE_ENV=staging" >> docker-compose.staging.yml
        echo "      - API_URL=${STAGING_API_URL}" >> docker-compose.staging.yml
        echo "      - AUTH_SECRET=${STAGING_AUTH_SECRET}" >> docker-compose.staging.yml
        echo "      - DATABASE_URL=${STAGING_DATABASE_URL}" >> docker-compose.staging.yml
        
        # Create production environment file
        echo "version: '3'" > docker-compose.prod.yml
        echo "services:" >> docker-compose.prod.yml
        echo "  blackflow-prod:" >> docker-compose.prod.yml
        echo "    environment:" >> docker-compose.prod.yml
        echo "      - NODE_ENV=production" >> docker-compose.prod.yml
        echo "      - API_URL=${PROD_API_URL}" >> docker-compose.prod.yml
        echo "      - AUTH_SECRET=${PROD_AUTH_SECRET}" >> docker-compose.prod.yml
        echo "      - DATABASE_URL=${PROD_DATABASE_URL}" >> docker-compose.prod.yml
      env:
        STAGING_API_URL: ${{ secrets.STAGING_API_URL }}
        STAGING_AUTH_SECRET: ${{ secrets.STAGING_AUTH_SECRET }}
        STAGING_DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
        PROD_API_URL: ${{ secrets.PROD_API_URL }}
        PROD_AUTH_SECRET: ${{ secrets.PROD_AUTH_SECRET }}
        PROD_DATABASE_URL: ${{ secrets.PROD_DATABASE_URL }}
    
    - name: Configure Nginx with domain
      run: |
        mkdir -p nginx/conf.d
        
        export DOMAIN_NAME="${{ secrets.DOMAIN_NAME }}"
        export STAGING_DOMAIN_NAME="staging.${{ secrets.DOMAIN_NAME }}"
        
        chmod +x scripts/nginx/create-nginx-conf.sh scripts/nginx/create-server-blocks.sh
        dos2unix scripts/nginx/create-nginx-conf.sh scripts/nginx/create-server-blocks.sh
        ./scripts/nginx/create-nginx-conf.sh
        
        cat > scripts/nginx/domain-variables.sh << EOF
        #!/bin/bash
        export DOMAIN_NAME="$DOMAIN_NAME"
        export STAGING_DOMAIN_NAME="$STAGING_DOMAIN_NAME"
        EOF
        chmod +x scripts/nginx/domain-variables.sh
        dos2unix scripts/nginx/domain-variables.sh
        
        ./scripts/nginx/create-server-blocks.sh
    
    - name: Ensure app directory exists
      run: |
        ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'sudo mkdir -p /home/ubuntu/app/nginx/ssl && sudo chown -R ubuntu:ubuntu /home/ubuntu/app'
    
    - name: Check if initial setup is needed
      id: check-setup
      run: |
        SETUP_NEEDED=$(ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "if [ -f /home/ubuntu/app/docker-compose.merged.yml ]; then echo 'false'; else echo 'true'; fi")
        echo "setup_needed=$SETUP_NEEDED" >> $GITHUB_OUTPUT
        
        # Check if SSL certs exist and aren't expiring soon
        SSH_OUTPUT=$(ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} "if [ -f /home/ubuntu/app/scripts/ssl/check-ssl-certs.sh ]; then chmod +x /home/ubuntu/app/scripts/ssl/check-ssl-certs.sh && /home/ubuntu/app/scripts/ssl/check-ssl-certs.sh; else if [ -f /home/ubuntu/app/nginx/ssl/cert.pem ] && [ -f /home/ubuntu/app/nginx/ssl/key.pem ]; then echo 'Certificates exist but expiration unknown'; else echo 'SSL certificates not found'; fi; fi")
        CERT_CODE=$?
        
        # Determine if SSL setup is needed based on both existence and expiration
        if [ $CERT_CODE -eq 0 ]; then
          SSL_SETUP_NEEDED="false"
          echo "SSL certificates exist and are valid for more than 7 days"
        else
          SSL_SETUP_NEEDED="true"
          echo "SSL certificates don't exist or will expire soon: $SSH_OUTPUT"
        fi
        echo "ssl_setup_needed=$SSL_SETUP_NEEDED" >> $GITHUB_OUTPUT

    - name: Setup or renew SSL certificates if needed
      if: steps.check-setup.outputs.ssl_setup_needed == 'true'
      run: |
        echo "SSL certificates setup or renewal needed..."
        chmod +x scripts/ssl/certbot-setup.sh scripts/ssl/check-ssl-certs.sh scripts/ssl/renew-ssl-certs.sh scripts/ssl/manage-ssl-certs.sh
        dos2unix scripts/ssl/certbot-setup.sh scripts/ssl/check-ssl-certs.sh scripts/ssl/renew-ssl-certs.sh scripts/ssl/manage-ssl-certs.sh
        
        # Copy all SSL management scripts to the server
        scp scripts/ssl/*.sh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/
        
        # Make sure app/scripts/ssl directory exists
        ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'sudo mkdir -p /home/ubuntu/app/scripts/ssl && sudo chown -R ubuntu:ubuntu /home/ubuntu/app/scripts'
        
        # Run the SSL management script
        ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'dos2unix ./manage-ssl-certs.sh && ./manage-ssl-certs.sh ${{ secrets.DOMAIN_NAME }} ${{ secrets.STAGING_DOMAIN_NAME }} ${{ secrets.CERTBOT_EMAIL }}'
        
        # Copy the SSL management scripts to the app directory for future use and ensure proper permissions
        ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'cp ~/manage-ssl-certs.sh ~/check-ssl-certs.sh ~/renew-ssl-certs.sh /home/ubuntu/app/scripts/ssl/ && chmod +x /home/ubuntu/app/scripts/ssl/*.sh && sudo chown ubuntu:ubuntu /home/ubuntu/app/scripts/ssl/*.sh'
        
        # Ensure proper SSL certificate permissions if they exist
        ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'if [ -d "/home/ubuntu/app/nginx/ssl" ]; then sudo chmod 600 /home/ubuntu/app/nginx/ssl/*.pem 2>/dev/null || true; sudo chown ubuntu:ubuntu /home/ubuntu/app/nginx/ssl/*.pem 2>/dev/null || true; fi'
  
    - name: Setup consolidated environment
      run: |
        # Create all necessary directories on server and ensure ubuntu user has Docker permissions
        ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'sudo mkdir -p /home/ubuntu/app/scripts/deploy /home/ubuntu/app/scripts/nginx /home/ubuntu/app/scripts/cleanup /home/ubuntu/app/scripts/ssl /home/ubuntu/app/nginx/conf.d /home/ubuntu/app/nginx/ssl /home/ubuntu/app/services && sudo chown -R ubuntu:ubuntu /home/ubuntu/app && sudo usermod -aG docker ubuntu'
        
        # Verify Docker permissions are effective
        ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'if id ubuntu | grep -q docker; then echo "Docker group already effective"; else echo "Docker group added, will be effective on next login"; fi'
        
        # Copy all necessary files
        scp -r scripts/* ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:/home/ubuntu/app/scripts/
        scp -r nginx/* ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:/home/ubuntu/app/nginx/
        scp docker-compose.prod.yml docker-compose.staging.yml ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:/home/ubuntu/app/
        
        # Fix line endings and make scripts executable on the server
        ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'cd /home/ubuntu/app && sudo apt-get update && sudo apt-get install -y dos2unix && sudo find scripts -name "*.sh" -type f -exec chmod +x {} \; -exec dos2unix {} \; && sudo chown -R ubuntu:ubuntu /home/ubuntu/app/scripts'
        
        # Create docker-compose.merged.yml on the server
        ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'cd /home/ubuntu/app && ./scripts/deploy/create-docker-compose.sh'
        
        # First time setup
        if [ "${{ steps.check-setup.outputs.setup_needed }}" = "true" ]; then
          echo "Performing initial setup..."
          
          # Clone repo and setup application
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'cd /home/ubuntu/app && ./scripts/cleanup/cleanup-docker.sh && if [ ! -d "blackflow" ]; then timeout 180 git clone https://github.com/samif0/blackflow.git blackflow || echo "Git clone timed out after 180 seconds"; fi && sudo docker-compose -f docker-compose.merged.yml -f docker-compose.prod.yml build blackflow-prod auth && sudo docker-compose -f docker-compose.merged.yml -f docker-compose.staging.yml build blackflow-staging && sudo docker-compose -f docker-compose.merged.yml -f docker-compose.prod.yml -f docker-compose.staging.yml up -d'
        else
          echo "Updating existing deployment..."
          # For normal deployments, just update the code and restart containers
          ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'cd /home/ubuntu/app && cd blackflow && timeout 120 git pull || echo "Git pull timed out after 120 seconds" && cd .. && sudo docker-compose -f docker-compose.merged.yml -f docker-compose.prod.yml build blackflow-prod auth && sudo docker-compose -f docker-compose.merged.yml -f docker-compose.staging.yml build blackflow-staging && sudo docker-compose -f docker-compose.merged.yml -f docker-compose.prod.yml -f docker-compose.staging.yml up -d'
        fi
        
        # Clean up
        ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'cd /home/ubuntu/app && sudo docker image prune -af --force'
 
    - name: Set up automated SSL certificate checks
      run: |
        # Create a cron job to check and renew certificates daily
        ssh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'dos2unix /home/ubuntu/app/scripts/ssl/manage-ssl-certs.sh && (crontab -l 2>/dev/null || true; echo "0 3 * * * /home/ubuntu/app/scripts/ssl/manage-ssl-certs.sh") | crontab -'
        echo "Set up daily SSL certificate check at 3 AM"
    
    - name: Verify deployments
      run: |
        echo "Deployments completed. Verifying health endpoints..."
        sleep 15
        PROD_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -k https://${{ secrets.DOMAIN_NAME }}/api/health || echo "failed")
        STAGING_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -k https://staging.${{ secrets.DOMAIN_NAME }}/api/health || echo "failed")
        
        if [[ "$PROD_STATUS" == "200" ]]; then
          echo "✅ Production endpoint is healthy (status: $PROD_STATUS)"
        else
          echo "⚠️ Warning: Production endpoint returned status: $PROD_STATUS"
        fi
        
        if [[ "$STAGING_STATUS" == "200" ]]; then
          echo "✅ Staging endpoint is healthy (status: $STAGING_STATUS)" 
        else
          echo "⚠️ Warning: Staging endpoint returned status: $STAGING_STATUS"
        fi
